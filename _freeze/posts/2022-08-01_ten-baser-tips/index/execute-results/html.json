{
  "hash": "23314dfb0d55945c67240f70798bcaea",
  "result": {
    "markdown": "---\ntitle: \"Ten `base-r` functions you might not know\"\ndate: \"2022-08-01\"\ncategories: [code, r, base-r, tips]\nimage: \"image.jpg\"\ndraft: true\n---\n\n\nIn this short post, we will go through 10 base r functions that you may have been underutilized.\n\n1.  `lengths` - This function returns the lengths of objects in a list, making it useful for quickly summarizing the structure of a data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a list of vectors\nmy_list = list(c(1, 2, 3), c(\"a\", \"b\", \"c\"), c(TRUE, TRUE, FALSE))\n\n# calculate the lengths of each vector in the list\nlengths(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3 3\n```\n:::\n:::\n\n\n2.  `rle` - This function computes the lengths and values of runs of equal values in a vector, making it useful for identifying patterns in data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector with repeated values\nmy_vector = c(1, 1, 1, 2, 2, 3, 3, 3, 3)\n\n# calculate the lengths and values of runs of equal values in the vector\nrle(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Length Encoding\n  lengths: int [1:3] 3 2 4\n  values : num [1:3] 1 2 3\n```\n:::\n:::\n\n\n3.  `ave` - This function calculates the mean of a vector, with the option to specify grouping variables for calculating means by group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a data frame with two variables\nmy_data = data.frame(\n  x = c(1, 2, 3, 4, 5),\n  y = c(\"a\", \"b\", \"c\", \"d\", \"e\")\n)\n\n# calculate the mean of variable \"x\"\nave(my_data$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3 3 3 3\n```\n:::\n\n```{.r .cell-code}\n# calculate the mean of variable \"x\" by the levels of variable \"y\"\nave(my_data$x, my_data$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n4.  `file_path_sans_ext` and `file_ext` - These functions allow for the manipulation of file paths, with \"file_path_sans_ext\" returning the file path without the extension and \"file_ext\" returning the file extension. \"baseenv\" allows for the creation of a new environment, which can be useful for managing variable scope.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a file path\nmy_file = \"~/data/my_file.txt\"\n\n# extract the file path without the extension\ntools::file_path_sans_ext(my_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"~/data/my_file\"\n```\n:::\n\n```{.r .cell-code}\n# extract the file extension\ntools::file_ext(my_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"txt\"\n```\n:::\n:::\n\n\n6.  `sprintf` - This function allows for the creation of formatted strings, making it useful for creating consistent output in reports or visualizations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a string with placeholders for variables\nmy_string = \"The value of x is %d and the value of y is %f\"\n\n# insert values into the placeholders\nsprintf(my_string, 1, 2.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The value of x is 1 and the value of y is 2.500000\"\n```\n:::\n:::\n\n\n7.  `sweep` - This function allows you to apply a function to a matrix or vector by a margin, making it useful for quickly performing calculations across rows or columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a matrix\nmy_matrix = matrix(1:9, nrow = 3)\n\n# apply the sum function across the rows of the matrix\nsweep(my_matrix, 1, colSums(my_matrix), \"+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    7   10   13\n[2,]   17   20   23\n[3,]   27   30   33\n```\n:::\n:::\n\n\n8.  `Map` - This function applies a function to each element of a list, returning a list of results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a list of vectors\nmy_list = list(r=rnorm(10), y=runif(10))\n\n# apply the sum function to each vector in the list\nMap(sum, my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$r\n[1] 1.853099\n\n$y\n[1] 4.047392\n```\n:::\n:::\n\n\n9.  `replace` - This function allows for the replacement of values in a vector or data frame, making it useful for data cleaning and manipulation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector with some missing values\nmy_vector = c(1, NA, 2, NA, 3)\n\n# replace the missing values with 0\nreplace(my_vector, is.na(my_vector), 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 2 0 3\n```\n:::\n:::\n\n\n10. `within` - This function allows for the evaluation of an expression within a specified environment, making it useful for controlling variable scope and accessing objects in different environments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a data frame\nmy_data = data.frame(\n  x = c(1, 2, 3, 4),\n  y = c(\"a\", \"b\", \"c\", \"d\")\n)\n\nwithin(my_data, mean(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 a\n2 2 b\n3 3 c\n4 4 d\n```\n:::\n:::\n\n\n11. `strrep` is used to repeat a string a specified number of times. Here is an example of how to use it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Repeat the string \"hello\" 5 times\nstrrep(\"hello\", 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hellohellohellohellohello\"\n```\n:::\n:::\n\n\nThis function can be useful for creating strings of repeated characters or words, or for padding strings with a certain character or word. It can also be useful for creating strings of a certain length by repeating a given string until it reaches the desired length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pad the string \"hello\" with underscores until it is 10 characters long\npadded_string = paste(\"hello\", strrep(\"_\", 10 - nchar(\"hello\")))\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}